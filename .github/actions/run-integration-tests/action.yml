name: "Run integration tests"
description: "Run Inspektor Gadget integration tests"

inputs:
  container_repo:
    description: 'The repository used as inspektor gadget deployment image repository.'
    required: true
  image_tag:
    description: 'The image tag used as inspektor gadget deployment image tag.'
    required: true
  kubernetes_distribution:
    description: 'The kubernetes distribution used to select distro specific config in tests.'
    required: true
  kubernetes_architecture:
    description: 'The CPU architecture used to select arch specific config in tests.'
    required: true
  runtime:
    description: 'The container runtime used to select runtime specific config in tests.'
    required: true

runs:
  using: "composite"
  steps:
    - name: Get kubectl-gadget-linux-amd64.tar.gz from artifact.
      uses: actions/download-artifact@v3
      with:
        name: kubectl-gadget-linux-amd64-tar-gz
        path: /home/runner/work/inspektor-gadget/inspektor-gadget/
    - name: Integration tests
      shell: bash
      run: |
        tar zxvf /home/runner/work/inspektor-gadget/inspektor-gadget/kubectl-gadget-linux-amd64.tar.gz

        cleanup() {
            echo "IntegrationTestsJob: Workflow run is being cancelled: $1 was received"
            trap - $1
            if [[ $1 == "SIGINT" ]]; then
              echo "IntegrationTestsJob: Start the clean-up..."
            else
              echo "IntegrationTestsJob: Just wait until the clean-up finishes..."
              return
            fi
            # Forward the SIGINT directly to test process but wait for current
            # active jobs since we can only wait for current shell child process.
            echo "IntegrationTestsJob: Notifying the integration tests process about the cancellation"
            kill -2 $(pidof inspektor-gadget.test) > /dev/null
            echo "IntegrationTestsJob: Waiting for the integration tests process to finish"
            wait $(jobs -p)
            echo "IntegrationTestsJob: We are done with the clean-up. Let the job exit"
            exit 0
        }

        # Capture the SIGINT to start the clean-up. Then, capture also the
        # SIGTERM to have those 2.5 extra seconds before the runner kills the
        # process tree:
        # https://docs.github.com/en/actions/managing-workflow-runs/canceling-a-workflow#steps-github-takes-to-cancel-a-workflow-run
        trap 'cleanup SIGINT' SIGINT
        trap 'cleanup SIGTERM' SIGTERM

        
        sleep 30 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 30 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 30 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 60 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 60 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 60 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 90 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 90 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 90 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 120 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 120 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 120 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 150 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 150 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 150 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 180 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 180 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 180 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &
        
        sleep 210 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 210 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 210 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &
        
        sleep 240 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 240 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 240 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &
        
        sleep 270 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 270 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 270 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 300 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 300 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 300 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 330 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 330 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 330 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 360 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 360 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 360 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        sleep 390 && docker exec minikube-${{ inputs.runtime }} bash -c 'crictl ps && crictl stats' &
        sleep 390 && docker exec minikube-${{ inputs.runtime }}-m02 bash -c 'crictl ps && crictl stats' &
        sleep 390 && top -b -n 1 > /tmp/top.txt && cat /tmp/top.txt &

        # https://mywiki.wooledge.org/SignalTrap#When_is_the_signal_handled.3F
        echo "IntegrationTestsJob: Start"
        set -o pipefail
        make \
          KUBERNETES_DISTRIBUTION=${{ inputs.kubernetes_distribution }} \
          KUBERNETES_ARCHITECTURE=${{ inputs.kubernetes_architecture }} \
          CONTAINER_REPO=${{ inputs.container_repo }} \
          IMAGE_TAG=${{ inputs.image_tag }} \
          -o kubectl-gadget integration-tests |& tee integration.log & wait $!
        echo "IntegrationTestsJob: Done"
    - name: Prepare and publish test reports
      if: always()
      continue-on-error: true
      uses: ./.github/actions/prepare-and-publish-test-reports
      with:
        test-log-file: integration.log

